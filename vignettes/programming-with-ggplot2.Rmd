---
title: "Programming With ggplot2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Programming With ggplot2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", fig.width = 7, fig.height = 7, fig.align = "center")
library(ggplot2)
```

For the programming bit, there is already several quite good articles: https://rpubs.com/hadley/97970, https://www.tidyverse.org/articles/2018/07/ggplot2-tidy-evaluation/

Need a good continuing example:

```{r}
ggplot(mpg) + 
  geom_bar(aes(x = class)) + 
  coord_flip()
```

## Making a plot function

```{r}
col_summary <- function(data, col) {
  ggplot(mpg) + 
    geom_bar(aes(x = !!enquo(col))) + 
    coord_flip()
}

col_summary(mpg, class)
```

### Creating a theme function

On themes: It's always good practice to start with an existing theme (e.g. `theme_grey()`) and then `%+replace%` the elements that should be changed. This is the right strategy even if seemingly all elements are replaced.

Call it `theme_*()`.

Examples: __cowplot__, __ggthemes__

```{r}
theme_col_summary <- function(...) {
  theme_grey(...) %+replace% 
    theme(
      panel.border = element_rect(size = 1, fill = NA),
      panel.background = element_blank(),
      panel.grid = element_line(colour = "grey80")
    )
}

col_summary(mpg, class) + 
  theme_col_summary()
```

## Using ggplot2 within a package

Programming with __ggplot2__ within a package adds several constraints, particularly if you would like to submit the package to CRAN. Functions within packages need to refer to functions in other packages explicitly (e.g., by importing them or using `::`), and be careful about non-standard evaluation (e.g., using `aes()` and `vars()`) to avoied a CMD check warning.

### Refering to ggplot2 within package functions

import them into the `NAMESPACE` (e.g., by adding `#' @importFrom ggplot2 ggplot` to any roxygen documentation block)  Note that if you import anything from __ggplot2__, you'll have to include it in Imports rather than Suggests. 

```{r}
#' @importFrom ggplot2 ggplot aes geom_bar coord_flip
#' @importFrom rlang !! enquo
col_summary <- function(data, col) {
  ggplot(mpg) + 
    geom_bar(aes(x = !!enquo(col))) + 
    coord_flip()
}
```

or using `::` (e.g., `ggplot2::ggplot()`). Note that `!!` and infix operators (e.g., `%+replace%`) must be imported or assigned, as R does not provide a way to qualify these operators.

```{r}
`!!` <- rlang::`!!`

col_summary <- function(data, col) {
  ggplot2::ggplot(mpg) + 
    ggplot2::geom_bar(ggplot2::aes(x = !!rlang::enquo(col))) + 
    ggplot2::coord_flip()
}
```

### Using aes() and vars() in a package function

To create any graphic using __ggplot2__ you will use `aes()` at least once. If your graphic uses facets, you will need to use `vars()`. Both of these functions are intended to refer to variables that exist in the data, so the CMD check will give you a warning if you try to use either inside a function. 

There are two situations in which you might use these. The first is when you already know the mapping in advance. In this case, you should use the `.data` pronoun from __rlang__:

```{r}
#' @importFrom rlang .data
residual_histogram <- function(fit, ...) {
  plot_data <- data.frame(residual = resid(fit))
  ggplot(plot_data, aes(x = .data$residual)) + geom_histogram(...)
}

test_fit <- lm(hwy ~ cty, data = mpg)
residual_histogram(test_fit)
```

If the user specifies a specific part of the mapping (like the variable from a data frame), you can either have this specified as a column name (e.g., `column = "class"`) or using the same kind of non-standard evaluation used by `aes()` and `vars()` (e.g., `column = class`). In the first case, use `rlang::sym()` to create an unevaluated expression with the name, then use `!!` to evaluate it within `aes()`.

```{r}
#' @importFrom rlang !! sym
col_summary <- function(data, col) {
  ggplot(mpg) + 
    geom_bar(aes(x = !!sym(col))) + 
    coord_flip()
}

col_summary(mpg, "class")
```


To use the same kind of non-standard evaluation that `aes()` uses, use `enquo()` to capture the user input, and `!!` pass the (unevaluated) user input in to `aes()`:

```{r}
#' @importFrom rlang !! enquo
col_summary <- function(data, col) {
  ggplot(mpg) + 
    geom_bar(aes(x = !!enquo(col))) + 
    coord_flip()
}

col_summary(mpg, class)
```

### Making a good plot function

Automatically generated plots usually require some kind of modification, so it's worth thinking about the limitations of your function.

- Have a separate function that transforms your object into one or more data frames. This lets users make their own plots. Good example is __ggdendro__, which creates dendrograms using __ggplot2__ but also computes the data necessary for users to make their own. For objects that can be converted into a single data frame, implementing the `ggplot2::fortify()` generic is a good way to do this (see `fortify.SpatialPolygonsDataFrame()`).

- `plot()` vs. `autoplot()`: make sure `plot()` methods `print()` their output:

```r
make_a_ggplot <- function(object, ...) {
  ggplot(object) + ...
}

plot.my_class <- function(x, ...) {
  print(make_a_ggplot(x))
}
```

Using `plot()` may lead to confusion as users may expect the ususal arguments to be implemented (e.g., `xlim`, `ylim`).

Don't implement an S3 generic like `plot()`, `fortify()`, or `autoplot()` if you don't have any control over the S3 object (it makes it hard for the package developer who does have control over the S3 to change the underlying data structure).

### Testing ggplot2 output

We suggest testing the output of ggplot2 in using the __vdiffr__ package, which is a tool to manage visual test cases (this is how we test __ggplot2__). If changes in __ggplot2__ or your code introduce a change in the visual output of a ggplot, tests will fail when you run them locally. These tests do not run on CRAN

- Use __testthat__: `usethis::use_testthat()` if you aren't already.
- Use `expect_doppleganger(<name of plot>, <ggplot objecct>)`

```r
test_that("output of ggplot() is stable", {
  vdiffr::expect_doppelganger("A blank plot", ggplot2::ggplot())
})
```

### Imports or Suggests

In documentation (examples, vignettes) make sure you put __ggplot2__ in `Suggests`.

If your package doesn't really use ggplot2 but would like to provide compatibility for other ggplot2 users, use Suggests (you may have to use some `.onLoad()` tricks to register S3). Can't find a good example with ggplot2, but __sf__ does this for __dplyr__.

If your package uses ggplot2 to visualize the data structures used by your package (e.g., __rstan__)


### Please don't do these things

- Use `annotate()` to avoid using `aes()`
- Use `aes_()` or `aes_string()`: These functions are deprecated and at some point will be removed
- Incluse __ggplot2__ in the Imports when you only use it in your package documentation (i.e., examples and/or vignettes).
