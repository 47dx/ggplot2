---
title: "Programming With ggplot2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Programming With ggplot2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", fig.show = "hide")
library(ggplot2)
```

This vignette is intended for package developers who use __ggplot2__ functions within their package functions and documentation. As of this writing, this includes over 2,000 packages on CRAN and many more elsewhere! Programming with __ggplot2__ within a package adds several constraints, particularly if you would like to submit the package to CRAN. In particular, programming within an R package changes the way you refer to functions from __ggplot2__ and how you use __ggplot2__'s non-standard evaluation within `aes()` and `vars()`.

## Referring to ggplot2 functions

As with any function from another package, you will have to list __ggplot2__ in your `DESCRIPTION` under `Imports` or `Suggests` and refer to its functions using `::` (e.g., `ggplot2::function_name`).

```{r}
mpg_drv_summary <- function() {
  ggplot2::ggplot(ggplot2::mpg) + 
    ggplot2::geom_bar(ggplot2::aes(x = .data$drv)) + 
    ggplot2::coord_flip()
}
```

```{r, include=FALSE}
# make sure this function runs!
mpg_drv_summary()
```

If you use __ggplot2__ functions frequently, you may wish to import one or more functions from __ggplot2__ into your `NAMESPACE`. If you use __roxygen2__, you can include `#' @importFrom ggplot2 <one or more function names>`. in any roxygen comment block (this will not work for datasets). If you do this, you will need to put __ggplot2__ in your `Imports` rather than your `Suggests`.

```{r}
#' @importFrom ggplot2 ggplot aes geom_bar coord_flip
mpg_drv_summary <- function() {
  ggplot(ggplot2::mpg) + 
    geom_bar(aes(x = drv)) + 
    coord_flip()
}
```

```{r, include=FALSE}
# make sure this function runs!
mpg_drv_summary()
```

If you use infix operators from __ggplot2__ like `%+replace%` and you want to keep __ggplot2__ in `Suggests`, you can assign the operator within the function before it is used.

```{r}
theme_custom <- function(...) {
  `%+replace%` <- ggplot2::`%+replace%`
  ggplot2::theme_grey(...) %+replace% 
    ggplot2::theme(panel.background = ggplot2::element_blank())
}
```

```{r, include=FALSE}
# make sure this function runs!
mpg_drv_summary() + theme_custom()
```

If you have __ggplot2__ in your `Imports` anyway, it is much easier to import the infix into your namespace.

```{r}
#' @importFrom ggplot2 %+replace%
theme_custom <- function(...) {
  ggplot2::theme_grey(...) %+replace% 
    ggplot2::theme(panel.background = ggplot2::element_blank())
}
```

```{r, include=FALSE}
mpg_drv_summary() + theme_custom()
```

Even if you use many __ggplot2__ functions in your package, it is unwise to use __ggplot2__ in `Depends` or import the entire package into your `NAMESPACE`. Using __ggplot2__ in `Depends` will attach __ggplot2__ when your package is attached, which includes when your package is tested. This makes it difficult to ensure that others can use the functions in your package without attaching it (i.e., using `::`). Similarly, importing all 450 of __ggplot2__'s exported objects into your namespace makes it difficult to separate the responsibility of your package and the responsibility of __ggplot2__, in addition to making it difficult for readers of your code to figure out where functions are coming from!

## Using aes() and vars() in a package function

To create any graphic using __ggplot2__ you will probably need to use `aes()` at least once. If your graphic uses facets, you might be using `vars()` or formula notation to refer to columns in the data. Both of these functions use non-standard evaluation, so if you try to use them in a function within a package they will result in a CMD check note:

```{r}
mpg_drv_summary <- function() {
  ggplot(mpg) + 
    geom_bar(aes(x = drv)) + 
    coord_flip()
}
```

```
N  checking R code for possible problems (2.7s)
   mpg_drv_summary: no visible binding for global variable ‘drv’
   Undefined global functions or variables:
     drv
```

If you already know the mapping in advance (like the above example) you should use the `.data` pronoun from __rlang__:

```{r}
#' @importFrom rlang .data
mpg_drv_summary <- function() {
  ggplot(mpg) + 
    geom_bar(aes(x = .data$drv)) + 
    coord_flip()
}
```

If the user specifies a part of the mapping, you can either have this specified as a column name (e.g., `col = "drv"`) or using the same kind of non-standard evaluation used by `aes()` and `vars()` (e.g., `col = drv`). In the first case, use `.data[[col]]`:

```{r}
#' @importFrom rlang .data
col_summary <- function(data, col) {
  ggplot(mpg) + 
    geom_bar(aes(x = .data[[col]])) + 
    coord_flip()
}

col_summary(mpg, "drv")
```

To use the same kind of non-standard evaluation that `aes()` uses, use `{{ col }}` to pass the unevaluated expression the user typed in `col` to `aes()`.

<!-- this uses development rlang, which is not yet released -->

```{r, eval=FALSE}
col_summary <- function(data, col) {
  ggplot(mpg) + 
    geom_bar(aes(x = {{ col }})) + 
    coord_flip()
}

col_summary(mpg, drv)
```

To summarise, if you know the mapping or facet specification in advance, use `aes(.data$col)` or `vars(.data$col)`. If you have the column name as a character scalar, use `aes(.data[[col]]` or `vars(.data[[col]])`. If you would like your function to look and feel like `aes()` and `vars()`, use `aes({{ col }})` or `vars({{ col }})`. 

You will see a lot of other ways to do this in the wild, but the syntax we use here is the only one we can guarantee will work in the future! In particular, don't use `aes_()` or `aes_string()`, as they are deprecated and may be removed in a future version. Finally, don't skip the step of creating a data frame and a mapping to pass in to `ggplot()` or its layers! You will see other ways of doing this in the wild, but these rely on undocumented behaviour and fail in unexpected ways.

## Best practices for common tasks

### Using ggplot2 to visualize an object

__ggplot2__ is commomly used in packages to visualize objects (e.g., in a `plot()`-style function).

```{r}
my_distr <- structure(
  c(
    "2seater" = 5 / 234,
    "compact" = 47 / 234,
    "midsize" = 41 / 234,
    "minivan" = 11 / 234,
    "pickup" = 33 / 234,
    "subcompact" = 35 / 234,
    "suv" = 62 / 234
  ),
  class = "discrete_distr"
)
```

Create a function that transforms the object into one or more data frames. This lets users make their own plots. Good example is __ggdendro__, which creates dendrograms using __ggplot2__ but also computes the data necessary for users to make their own.

```{r}
discrete_distr_data <- function(x, ...) {
  data.frame(
    value = names(x),
    probability = as.numeric(x),
    stringsAsFactors = FALSE
  )
}
```

Implement the `autoplot()` method for your object

```{r}
#' @importFrom ggplot2 autoplot
#' @importFrom rlang .data
autoplot.discrete_distr <- function(object, ...) {
  plot_data <- discrete_distr_data(object)
  ggplot(plot_data, aes(.data$value, .data$probability)) +
    geom_col() +
    coord_flip() +
    labs(x = "Value", y = "Probability")
}

autoplot(my_distr)
```

- `plot()` vs. `autoplot()`: make sure `plot()` methods `print()` their output:

```{r}
#' @importFrom graphics plot
plot.discrete_distr <- function(x, ...) {
  print(autoplot(x))
}
```

If you don't use __ggplot2__ for your visualizations but would like to implement `autoplot()` for users that do, it is possible to register your generics only if __ggplot2__ is installed using `vctrs::s3_register()`.

```{r}
.onLoad <- function(...) {
  if (requireNamespace("ggplot2", quietly = TRUE)) {
    vctrs::s3_register("ggplot2::autoplot", "discrete_distr")
  }
}
```

Don't implement an S3 generic like `plot()`, or `autoplot()` if you don't have any control over the S3 object (it makes it hard for the package developer who does have control over the S3 to change the underlying data structure).

### Creating a new theme

When creating a new theme, it's always good practice to start with an existing theme (e.g. `theme_grey()`) and then `%+replace%` the elements that should be changed. This is the right strategy even if seemingly all elements are replaced, as not doing so makes it difficult for us to improve themes by adding new elements. There are many excellent examples of themes in the __ggthemes__ package.

```{r}
#' @importFrom ggplot2 %+replace%
theme_custom <- function(...) {
  theme_grey(...) %+replace% 
    theme(
      panel.border = element_rect(size = 1, fill = NA),
      panel.background = element_blank(),
      panel.grid = element_line(colour = "grey80")
    )
}

mpg_drv_summary() + theme_custom()
```

It is important that the theme be calculated after the package is loaded. If not, the theme object is stored in the compiled bytecode of the built package, which may or may not align with you installed version of __ggplot2__! If your package has a default theme for its visualizations, the correct way to load it is to have a function that returns the default theme:

```{r}
default_theme <- function() {
  theme_custom()
}

mpg_drv_summary2 <- function() {
  mpg_drv_summary() + default_theme()
}
```

### Testing ggplot2 output

We suggest testing the output of ggplot2 in using the __vdiffr__ package, which is a tool to manage visual test cases (this is how we test __ggplot2__). If changes in __ggplot2__ or your code introduce a change in the visual output of a ggplot, tests will fail when you run them locally or on Travis. These tests do not run on CRAN

- Use __testthat__: `usethis::use_testthat()` if you aren't already.
- Add __vdiffr__ to Suggests in your DESCRIPTION (`usethis::use_package("vdiffr", "Suggests")`).
- Use `expect_doppleganger(<name of plot>, <ggplot object>)`

```r
test_that("output of ggplot() is stable", {
  vdiffr::expect_doppelganger("A blank plot", ggplot2::ggplot())
})
```

Don't use `expect_reference()`, or test the internal representation of a ggplot object (unless your package created some part of the internal representation).
